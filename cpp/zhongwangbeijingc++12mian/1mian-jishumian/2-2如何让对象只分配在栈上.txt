如何让对象只分配在栈上，这个看过其实很简单，我脑抽了一时没反应过来，幸好后来想起来了，答了把new重载或者设为私有，还可以delete。

https://wenku.baidu.com/view/29fdab2d51ea551810a6f524ccbff121dc36c556.html
https://blog.csdn.net/SuperWe/article/details/51497013


1、只能在堆上分配类对象，就是不能静态建立类对象，即不能直接调用类的构造函数。


编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。因此，将析构函数设为私有，类对象就无法建立在栈上了

class A  
{  
public:  
    A(){}  
    void destory(){delete this;}  
private:  
    ~A(){}  
};  

上述方法的缺点：

一、无法解决继承问题。如果A作为其它类的基类，则析构函数通常要设为virtual，然后在子类重写，以实现多态。因此析构函数不能设为private。还好C++提供了第三种访问控制，protected。将析构函数设为protected可以有效解决这个问题，类外无法访问protected成员，子类则可以访问。

二、类的使用很不方便，使用new建立对象，却使用destory函数释放对象，而不是使用delete。（使用delete会报错，因为delete对象的指针，会调用对象的析构函数，而析构函数类外不可访问）这种使用方式比较怪异。为了统一，可以将构造函数设为protected，然后提供一个public的static函数来完成构造，这样不使用new，而是使用一个函数来构造，使用一个函数来析构。代码如下，类似于单例模式：

class A  
{  
protected:  
    A(){}  
    ~A(){}  
public:  
    static A* create()  
    {  
        return new A();  
    }  
    void destory()  
    {  
        delete this;  
    }  
};  


//--------------------------

2、只能在栈上分配类对象

只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。虽然你不能影响new operator的能力（因为那是C++语言内建的），但是你可以利用一个事实：new operator 总是先调用 operator new,而后者我们是可以自行声明重写的。因此，将operator new()设为私有即可禁止对象被new在堆上。代码如下：

class A  
{  
private:  
    void* operator new(size_t t){}     // 注意函数的第一个参数和返回值都是固定的  
    void operator delete(void* ptr){} // 重载了new就需要重载delete  
public:  
    A(){}  
    ~A(){}  
};  



思考：回顾在栈上创建对象和在堆上创建对象的共同点，我们会发现，无论是A a；还是A* a=new A()；都会由编译器在类外部调用类的构造函数来创建对象。同样在释放内存空间时候也是会由编译器调用类的析构函数来释放。
不同点在于：
栈对象创建过程中分配内存然后调用构造函数和对象释放过程中释放内存然后析构函数的调用都是编译器自动完成的。
而堆对象的创建过程中需要先由编译器显式的调用operator new（）函数进行内存分配，堆的释放过程中需要先由编译器显式的调用operator delete（）函数，然后编译器自动调用析构函数。
为了只能在栈上创建对象，那么我们就可以将operator new（）函数和operator delete（）函数进行重载，这两个函数不做任何事情不分配内存，并将他们设置为private，那么编译器就无法调用这两个函数。也就不能再堆上创建对象了，此时的构造函数和析构函数还是可以被编译器自由的调用创建栈对象
为了只能在堆上创建对象，那么我们就必须让编译器不能自动调用构造函数和析构函数（虽然编译器能够自动分配内存但是没有调用构造函数，栈对象就没办法创建完成）。所以将构造函数和析构函数都设置为protected，这样编译器就不能调用了，但是创建堆对象也要由编译器调用构造函数和析构函数怎么办呢，得益于堆对象的创建过程需要调用类中定义的函数，那么我们可以定义两个函数create和destroy函数分别在内部调用构造函数和析构函数，这样就可以由编译器在堆上创建和释放对象。