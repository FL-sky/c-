~~前言

ACID，是指数据库管理系统（DBMS）在写入或更新资料的过程中，为保证事务（transaction）是正确可靠的，所必须具备的四个特性：
原子性（atomicity，或称不可分割性）、一致性（consistency）、隔离性（isolation，又称独立性）、持久性（durability）

Atomicity（原子性）：
一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。
事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
Consistency（一致性）：
在事务开始之前和事务结束以后，数据库的完整性没有被破坏。
这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
Isolation（隔离性）：
数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）。
Durability（持久性）：
事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

～～
隔离级别主要用于ACID中的“I”属性，即隔离。让我们快速回顾一下ACID属性。

A-原子性:它表示事务中的所有指令都应该以原子方式发生。原子性仅仅意味着它不能被分解，因此事务的执行就像它是一个单独的步骤。
例如：A想转500块钱给B，称之为事务。原子性保证了A的余额将被扣除500，B的余额将增加500。
这个增加和扣除都是在一个步骤里发送。想象一下如果不是原子的话会发生混乱。例如，A的钱被扣除了，然后交易失败了，B账户未收到转账。

C-一致性：这确保数据库始终处于一致或有效状态。使用上面相同的例子，假设在交易之前，A的余额是1000元，B的余额是2000元。交易事务完成后，希望看到A的余额=500，B=2500。如果我们思考一下，这两个状态都是有效的。不能让A的余额更新到500，而B的余额不是2500。 因此，在这里，他们的余额的总和可以被认为是一种状态，它应该保持一致，在交易之前和之后。

I-隔离性：当多个事务同时运行时，此属性可确保这些事务不受彼此的影响，从而防止出现问题。也就是说，如果事务按顺序运行，结果应该与并行获得的结果相同。举个例子，假设有两个并发的事务正在进行: A→B和A→C在每笔交易中转移500。 在多种情况下，并发可能会导致一些问题，比如T1将A的余额读取为1000，同时T2将A的余额读取为1000。分别扣除500发给B和C这导致了问题，因为现在两者都将更新A的余额为500。 由于A的余额现在是500卢比，这与一致性相矛盾，因为在这两笔交易之后A的预期余额应该是0。

我们有几个隔离级别，取决于我们希望事务执行有多严格，这些是本文的主要重点。

D-持久性：它确保一旦事务提交，我们不应该失去它的状态，并且必须被持久化。例如，A有1000元，它把500转给了B。现在，每次我们查询A的余额时，我们应该得到最新的值，不能丢失这些细节。

让我们讨论一下隔离级别，以及为什么在并发环境中首先需要这些级别。

并发环境中的问题:

https://baijiahao.baidu.com/s?id=1711165655558555911&wfr=spider&for=pc