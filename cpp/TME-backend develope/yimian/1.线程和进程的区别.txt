1.线程和进程的区别

（我说线程能提高并发度，线程切换开销比进程小，面试官追问为什么，我从环境上下文的角度回答，面试官觉得这不是关键。。）

-----------

https://www.nowcoder.com/tutorial/93/7474823e71be4850a4b856290d230e20
3.2 操作系统

2.24 说说进程、线程、协程是什么，区别是什么？
参考回答

1.进程：程序是指令、数据及其组织形式的描述，而进程则是程序的运行实例，包括程序计数器、寄存器和变量的当前值。

2.线程：微进程，一个进程里更小粒度的执行单元。一个进程里包含多个线程并发执行任务。

3.协程：协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行。

区别：

1.线程与进程的区别：

（1）一个线程从属于一个进程；一个进程可以包含多个线程。

（2）一个线程挂掉，对应的进程挂掉；一个进程挂掉，不会影响其他进程。

（3）进程是系统资源调度的最小单位；线程CPU调度的最小单位。

（4）进程系统开销显著大于线程开销；线程需要的系统资源更少。

（5）进程在执行时拥有独立的内存单元，多个线程共享进程的内存，如代码段、数据段、扩展段；但每个线程拥有自己的栈段和寄存器组。

（6）进程切换时需要刷新TLB并获取新的地址空间，然后切换硬件上下文和内核栈，线程切换时只需要切换硬件上下文和内核栈。

（7）通信方式不一样。

（8）进程适应于多核、多机分布；线程适用于多核

2.线程与协程的区别：

（1）协程执行效率极高。协程直接操作栈基本没有内核切换的开销，所以上下文的切换非常快，切换开销比线程更小。

（2）协程不需要多线程的锁机制，因为多个协程从属于一个线程，不存在同时写变量冲突，效率比线程高。

（3）一个线程可以有多个协程。


------------------

为什么切换线程比切换进程开销小
https://www.cnblogs.com/yvkm/p/10619001.html

首先要明白进程是什么：

　　关于进程的定义有很多，一个经典的定义是一个执行中程序的实例，进程是程序的动态表现。  一个程序进行起来后，会使用很多资源，比如使用寄存器，内存，文件等。每当切换进程时，必须要考虑保存当前进程的状态。状态包括存放在内存中的程序的代码和数据，它的栈、通用目的寄存器的内容、程序计数器、环境变量以及打开的文件描述符的集合，这个状态叫做上下文（Context）。可见，想要切换进程，保存的状态还不少。

其次就要了解线程是什么：

　　线程存在于进程中，一个进程可以有一个或多个线程。线程是运行在进程上下文中的逻辑流，简单说，线程可以理解为一个方法(Java)或函数（C），这个线程可以独立完成一项任务。同样线程有自己的上下文，包括唯一的整数线程ID， 栈、栈指针、程序计数器、通用目的寄存器和条件码。可以理解为线程上下文是进程上下文的子集。

 

由于保存线程的上下文明显比进程的上下文小，因此系统切换线程时，必然开销更小。

【内容来自CSAPP chapter 8 & 12】


线程调度为什么比进程调度更少开销？
https://www.cnblogs.com/gmpy/p/10265284.html


任务调度的开销#
既然我们知道了进程和线程在linux实现上的关系，我们再来分析，为什么说线程调度比进程调度开销更小？

或许你有这样的疑问，既然在linux实现上，线程都是独立的struct task_struct，都参与任务调度，那这里说的线程调度和进程调度怎么区分？

我们不妨这样定义：

Copy
线程调度：使用相同资源的`struct task_struct`之间的调度
进程调度：使用不同资源的`struct task_struct`之间的调度
基于这样的定义，为了方便分析问题，我们回顾一下任务调度的开销主要有什么？

Copy
1. CPU执行任务调度的开销，主要是进程上下文切换的开销
2. 任务调度后，CPU Cache/TLB不命中，导致缺页中断的开销
对于第1点的开销，不管是进程调度还是线程调度都是必须的，所以，两者的差异体现在第2点。

再看回我们对“进程调度”和“线程调度”的定义，有没觉得灵光一闪？既然线程调度的struct task_struct都使用相同的资源，是不是就意味着，我即使切换到了其他的线程，CPU Cache/TLB命中的概率会高很多？相反，进程调度使用的是不同的资源，每次换了个进程，就意味着原有的Cache就不适用了，没命中，就触发更多的缺页中断，开销自然就更多。

所以，我们明白了，线程调度为什么比进程调度更少开销。



进程切换分析（2）：TLB处理
http://www.wowotech.net/process_management/context-switch-tlb.html




TLB表作用及特点
https://blog.csdn.net/weichi7549/article/details/107589606

TLB:Translation Lookaside Buffer.

根据功能可以译为[快表]，直译可以翻译为[旁路转换缓冲]，也可以把它理解成[页表缓冲]。
里面存放的是一些页表文件（[虚拟地址到物理地址的转换表]）。

当处理 器要在主内存寻址时，不是直接在内存的物理地址里查找的，而是通过一组虚拟地址转换到主内存的物理地址，
<TLB就是负责将虚拟内存地址翻译成实际的物理内存地址>，而CPU寻址时会优先在TLB中进行寻址。处理器的性能就和寻址的命中率有很大的关系。