1.4.4 请你来介绍一下 STL 的空间配置器（allocator）
参考回答

    一般情况下,一个程序包括数据结构和相应的算法，而数据结构作为存储数据的组织形式，
    与内存空间有着密切的联系。在C++ STL中，空间配置器便是用来实现内存空间
    (一般是内存，也可以是硬盘等空间)分配的工具，他与容器联系紧密，
    每一种容器的空间分配都是通过空间分配器alloctor实现的。

答案解析

1.两种C++类对象实例化方式的异同

    在c++中，创建类对象一般分为两种方式：一种是直接利用构造函数,直接构造类对象，如 Test test()；
    另一种是通过new来实例化一个类对象，如 Test *pTest = new Test；那么，这两种方式有什么异同点呢？

我们知道，内存分配主要有三种方式：

（1） 静态存储区分配：内存在程序编译的时候已经分配好，这块内存在程序的整个运行空间内都存在。
如全局变量,静态变量等。

（2） 栈空间分配：程序在运行期间，函数内的局部变量通过栈空间来分配存储（函数调用栈），
当函数执行完毕返回时，相对应的栈空间被立即回收。主要是局部变量。 

（3）堆空间分配：程序在运行期间，通过在堆空间上为数据分配存储空间，
通过malloc和new创建的对象都是从堆空间分配内存，这类空间需要程序员自己来管理，
必须通过free()或者是delete()函数对堆空间进行释放，否则会造成内存溢出。

那么，从内存空间分配的角度来对这两种方式的区别，就比较容易区分:

（1）对于第一种方式来说，是直接通过调用Test类的构造函数来实例化Test类对象的,
如果该实例化对象是一个局部变量，则其是在栈空间分配相应的存储空间。 
（2）对于第二种方式来说,就显得比较复杂。这里主要以new类对象来说明一下。
new一个类对象,其实是执行了两步操作：
首先,调用new在堆空间分配内存,然后调用类的构造函数构造对象的内容；
同样，使用delete释放时，也是经历了两个步骤：
首先调用类的析构函数释放类对象，然后调用delete释放堆空间。

2.C++ STL空间配置器实现

很容易想象，为了实现空间配置器，完全可以利用new和delete函数并对其进行封装实现STL的空间配置器，
的确可以这样。
但是，为了最大化提升效率，SGI STL版本并没有简单的这样做，
而是采取了一定的措施，实现了更加高效复杂的空间分配策略。
由于以上的构造都分为两部分，所以，在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。

        内存配置操作: 通过alloc::allocate()实现
        内存释放操作: 通过alloc::deallocate()实现
        对象构造操作: 通过::construct()实现
        对象释放操作: 通过::destroy()实现

    关于内存空间的配置与释放，SGI STL采用了两级配置器：
    一级配置器主要是考虑大块内存空间，利用malloc和free实现；
    二级配置器主要是考虑小块内存空间而设计的（为了最大化解决内存碎片问题，进而提升效率），
    采用链表free_list来维护内存池（memory pool），free_list通过union结构实现，
    空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。