// 1.3.21 简述一下虚函数和纯虚函数，以及实现原理
// C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。
// 这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。如果调用非虚函数，则无论实际对象是什么类型，都执行基类类型所定义的函数。
// 非虚函数总是在编译时根据调用该函数的对象，引用或指针的类型而确定。如果调用虚函数，则直到运行时才能确定调用哪个函数，运行的虚函数是引用所绑定或指针所指向的对象所属类型定义的版本。
// 虚函数必须是基类的非静态成员函数。
// 虚函数的作用是实现动态联编，也就是在程序的运行阶段动态地选择合适的成员函数，在定义了虚函数后，可以在基类的派生类中对虚函数重新定义，在派生类中重新定义的函数应与虚函数具有相同的形参个数和形参类型。
// 以实现统一的接口，不同定义过程。如果在派生类中没有对虚函数重新定义，则它继承其基类的虚函数。

#include <bits/stdc++.h>
using namespace std;

int main1()
{
    class Person
    {
    public:
        //虚函数
        virtual void GetName()
        {
            cout << "PersonName:xiaosi" << endl;
        };
    };
    class Student : public Person
    {
    public:
        void GetName()
        {
            cout << "StudentName:xiaosi" << endl;
        };
    };
    //指针
    Person *person = new Student();
    //基类调用子类的函数
    person->GetName(); // StudentName:xiaosi
    return 0;
}

// 虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。
// 在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。
// 这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

// 2.纯虚函数是在基类中声明的虚函数，它在基类中没有定义，但要求任何派生类都要定义自己的实现方法。
// 在基类中实现纯虚函数的方法是在函数原型后加“=0” virtualvoid GetName() =0。
// 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔雀等子类，但动物本身生成对象明显不合常理。
// 为了解决上述问题，将函数定义为纯虚函数，则编译器要求在派生类中必须予以重写以实现多态性。
// 同时含有纯虚拟函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。
// 将函数定义为纯虚函数能够说明，该函数为后代类型提供了可以覆盖的接口，但是这个类中的函数绝不会调用。
// 声明了纯虚函数的类是一个抽象类。所以，用户不能创建类的实例，只能创建它的派生类的实例。
// 必须在继承类中重新声明函数（不要后面的＝0）否则该派生类也不能实例化，而且它们在抽象类中往往没有定义。
// 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的缺省实现。
// 所以类纯虚函数的声明就是在告诉子类的设计者，“你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它”。

int main()
{ //抽象类
    class Person
    {
    public:
        //纯虚函数
        virtual void GetName() = 0;
    };
    class Student : public Person
    {
    public:
        Student(){};
        void GetName()
        {
            cout << "StudentName:xiaosi" << endl;
        };
    };
    Student student;
    student.GetName();
    return 0;
}