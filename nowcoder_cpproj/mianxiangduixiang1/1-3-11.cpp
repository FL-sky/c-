// 1.浅拷贝：又称值拷贝，将源对象的值拷贝到目标对象中去，本质上来说源对象和目标对象共用一份实体，只是所引用的变量名不同，地址其实还是相同的。举个简单的例子，你的小名叫西西，大名叫冬冬，当别人叫你西西或者冬冬的时候你都会答应，这两个名字虽然不相同，但是都指的是你。

// 2.深拷贝，拷贝的时候先开辟出和源对象大小一样的空间，然后将源对象里的内容拷贝到目标对象中去，这样两个指针就指向了不同的内存位置。并且里面的内容是一样的，这样不但达到了我们想要的目的，还不会出现问题，两个指针先后去调用析构函数，分别释放自己所指向的位置。即为每次增加一个指针，便申请一块新的内存，并让这个指针指向新的内存，深拷贝情况下，不会出现重复释放同一块内存的错误。

// 3.深拷贝的实现：深拷贝的拷贝构造函数和赋值运算符的重载传统实现：
#include <bits/stdc++.h>
using namespace std;
class STRING
{
    char *_str;
    STRING(const STRING &s)
    {
        //_str = s._str;
        _str = new char[strlen(s._str) + 1];
        strcpy_s(_str, strlen(s._str) + 1, s._str);
    }
    // 这里的拷贝构造函数我们很容易理解，先开辟出和源对象一样大的内存区域，然后将需要拷贝的数据复制到目标拷贝对象 ， 那么这里的赋值运算符的重载是怎么样做的呢？
    STRING &operator=(const STRING &s)
    {
        if (this != &s)
        {
            // this->_str = s._str;
            delete[] _str;
            this->_str = new char[strlen(s._str) + 1];
            strcpy_s(this->_str, strlen(s._str) + 1, s._str);
        }
        return *this;
    }
    // s2 = s1
    //  起初，s2被构造出来以后，我们想把s1的内容放到s2里，这里就存在一个问题, s2的空间比s1大就可以直接将内容拷贝给s2，那如果s2的空间比s1还小的话是不是还得分情况讨论呢?在这里，我们有这样—种方法:第一步:先释放旧空间
    //  第二步:开辟出一段和s1—样大的空间来第三步:将s1的值赋给s2

    // 这种方法解决了我们的指针悬挂问题，通过不断的开空间让不同的指针指向不同的内存，以防止同一块内存被释放两次的问题。
};
